#!/usr/bin/env gosh

(add-load-path "@@server-data-dir@@")

(define-module chaton.viewer
  (use srfi-1)
  (use srfi-13)
  (use srfi-27)
  (use chaton)
  (use gauche.threads)
  (use gauche.net)
  (use gauche.logger)
  (use gauche.fcntl)
  (use text.html-lite)
  (use text.tree)
  (use rfc.822)
  (use file.util)
  (use util.match)
  (export run-viewer-server)
  )
(select-module chaton.viewer)

;; Global data shared between threads.  Accessor should lock *mutex*.
(define *mutex* (make-mutex))
(define *cv* (make-condition-variable))
(define *size* 0)
(define *last-state* '(#f . #f))
(define *text-map* (make-tree-map = <))

;;;
;;;   Main entry
;;;

(define (run-viewer-server port source)
  (let1 server-sock (make-server-socket 'inet port :reuse-addr? #t)
    (spawn-monitor source)
    (guard (e [else (socket-close server-sock) (raise e)])
      (let loop ()
        (spawn-child (socket-accept server-sock))
        (loop)))))

;;;
;;;   Monitor thread
;;;

(define (spawn-monitor source)
  (log-format "monitor start on ~s" source)
  (mutex-lock! *mutex*)
  (pull-text! source #t)                ; this unlocks mutex when error.
  (mutex-unlock! *mutex*)
  (thread-start! (make-thread (cut do-monitor source))))

(define (do-monitor source)
  (guard (e [else (log-format "monitor error: ~s" (ref e'message))])
    (let loop ()
      (and (file-exists? source)
           (let1 s (file-size source)
             (mutex-lock! *mutex*)
             (unless (or (not s) (not *size*) (= s *size*))
               (log-format "monitor: source extended to ~s" s)
               (pull-text! source (< s *size*))
               (condition-variable-broadcast! *cv*))
             (mutex-unlock! *mutex*)))
      (sys-sleep 1)
      (loop)))
  (do-monitor source))

;; Reads source file into *text-map*, updates global data.
;; *mutex* must be locked by the caller.   If an error occurs,
;; pull-text! unlocks *mutex*.
(define (pull-text! source trunc?)
  (when trunc? (tree-map-clear! *text-map*))
  (guard (e [else (mutex-unlock! *mutex*) (raise e)])
    (let ([pos (if trunc? 0 *size*)]
          [last-state (if trunc? '(#f . #f) *last-state*)])
      (receive (ttree new-state new-pos)
          (chaton-render-from-file source pos last-state)
        (tree-map-put! *text-map* pos (tree->string ttree))
        (set! *last-state* new-state)
        (set! *size* new-pos)))))

;;;
;;;   Comet threads
;;;

(define (spawn-child csock)
  (log-child csock "start")
  (thread-start! (make-thread (cut do-child csock))))

(define (do-child csock)
  (unwind-protect
      (guard (e [(eq? e 'eof) (log-child csock "disconnected")]
                [else (log-child csock "error ~s" (ref e'message))])
        (client-counter 'inc)
        (let1 pos (get-header csock)
          (if (>= pos 0)
            (emit-tail csock pos)
            (emit-skeleton (socket-output-port csock)))
          (log-child csock "finishing")))
    (begin
      (client-counter 'dec)
      (socket-close csock))))

;; returns the integer parameter given to the query
(define (get-header csock)
  (or (and-let* ([in (socket-input-port csock)]
                 [req (read-line in)]
                 [ (string? req) ]
                 [m (#/^GET\s+\/(?:\?t=\w+(?:&p=(\d+))?)?\s+HTTP\/1.1/i req)]
                 [hdrs (rfc822-header->list in)])
        (log-child csock "request ~s" req)
        (cond [(m 1) => x->integer] [else -1]))
      (raise 'eof))) 

;; NB: it may be more efficient if we send out existing content here,
;; instead of letting client to fetch it immediately after this reply.
;; A possible option for future development.
(define (emit-skeleton out)
  (write-tree (make-skeleton) out)
  (flush out))

(define (emit-tail csock pos)
  (let loop ()
    (mutex-lock! *mutex*)
    (cond [(equal? pos *size*)
           (if (mutex-unlock! *mutex* *cv* (+ 30 (random-integer 30)))
             (loop)
             (send-ping pos csock))]
          [(< pos *size*)
           (let ([s *size*] [t (text-retrieve *text-map* pos)])
             (mutex-unlock! *mutex*)
             (send-diff pos s t csock))]
          [else                         ;file is truncated?
           (let ([s *size*] [t (text-retrieve *text-map* 0)])
             (mutex-unlock! *mutex*)
             (send-diff 0 s t csock))])))

(define (send-diff start end text csock)
  (log-child csock "sending ~s-~s" start end)
  (send-json (format "{'pos':~s,'nc':~s,'ver':~s,'text':~s}"
                     end (client-counter 'get) "@@version@@"
                     text)
             csock))

(define (send-ping pos csock)
  (log-child csock "pinging back")
  (send-json (format "{'pos':~s,'nc':~s,'ver':~s,'text':''}"
                     pos (client-counter 'get) "@@version@@")
             csock))

(define (send-json json csock) 
  (let1 out (socket-output-port csock)
    (format out "HTTP/1.1 200 OK\r\n\
	         Content-type: application/json; charset=utf-8\r\n\
	         Content-length: ~s\r\n\r\n\
	         ~a" (string-size json) json)
    (flush out)))

(define (text-retrieve tmap start)
  (let loop ([key start]
             [r   '()])
    (if (not key)
      (string-concatenate-reverse r)
      (loop (tree-map-successor tmap key)
            (cons (tree-map-get tmap key "") r)))))

(define (log-child csock fmt . args)
  (log-format "(~a) ~a" (child-name csock) (apply format fmt args)))

(define (child-name csock)
  (and-let* ([addr (socket-address csock)])
    (sockaddr-name addr)))

;;;
;;;   Client counter
;;;

(define client-counter
  (let ([n 0] [mutex (make-mutex)])
    (lambda (msg)
      (case msg
        [(inc)  (with-locking-mutex mutex (lambda () (inc! n) n))]
        [(dec)  (with-locking-mutex mutex (lambda () (dec! n) n))]
        [(get)  n]
        [(reset)(with-locking-mutex mutex (lambda () (set! n 0)))]))))

;;;
;;;   Content to distribute
;;;

(define (make-skeleton)
  (html:html
   (html:head (html:title "Test")
              (html:link :href "@@httpd-url@@@@url-path@@chaton.css" :rel "Stylesheet" :type "text/css")
              (html:script :src "@@prototype-url@@" :type "text/javascript")
              (html:script :src "@@httpd-url@@@@url-path@@@@chaton-js@@"
                           :type "text/javascript"))
   (html:body
    :onload "fetchContent();"
    (html:div :id "view-pane")
    (html:div :id "status-pane" (html:p :id "status-line" "Connecting..."))
    )))

;;;===================================================================

(select-module user)
(use gauche.logger)
(use gauche.parseopt)
(import chaton.viewer)

(define (main args)
  (let-args (cdr args) ([port "p=i" @@comet-port@@]
                        [file "f=s" "@@server-data-dir@@data/current.dat"]
                        [log  "l=s" "@@server-data-dir@@logs/comet.log"])
    (log-open (if (equal? log "-") #t log))
    (run-viewer-server port file))
  0)

;; Local variables:
;; mode: scheme
;; end:
