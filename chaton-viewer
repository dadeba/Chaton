#!/usr/bin/env gosh

(add-load-path "@@server-data-dir@@")

(define-module chaton.viewer
  (use srfi-1)
  (use srfi-13)
  (use srfi-27)
  (use chaton)
  (use gauche.threads)
  (use gauche.net)
  (use gauche.logger)
  (use gauche.fcntl)
  (use text.html-lite)
  (use text.tree)
  (use rfc.822)
  (use file.util)
  (use util.match)
  (export run-viewer-server restart-viewer-server shutdown-viewer-server)
  )
(select-module chaton.viewer)

;; Global data shared between threads.  Accessor should lock *mutex*.
(define *mutex* (make-mutex))
(define *cv* (make-condition-variable))
(define *size* 0)
(define *last-state* '(#f . #f))
(define *text-map* (make-tree-map = <))

;;;
;;;   Main entry
;;;

(define (run-viewer-server port source)
  (initialize port)
  (let1 server-sock (make-server-socket 'inet port :reuse-addr? #t)
    (spawn-monitor source)
    (guard (e [else (socket-close server-sock) (raise e)])
      (let loop ()
        (spawn-child (socket-accept server-sock))
        (loop)))))

;;;
;;;   Monitor thread
;;;

(define (spawn-monitor source)
  (log-format "monitor start on ~s" source)
  (mutex-lock! *mutex*)
  (pull-text! source #t)                ; this unlocks mutex when error.
  (mutex-unlock! *mutex*)
  (thread-start! (make-thread (cut do-monitor source))))

(define (do-monitor source)
  (guard (e [else (log-format "monitor error: ~s" (ref e'message))])
    (let loop ()
      (and (file-exists? source)
           (let1 s (file-size source)
             (mutex-lock! *mutex*)
             (unless (or (not s) (not *size*) (= s *size*))
               (log-format "monitor: source extended to ~s" s)
               (pull-text! source (< s *size*))
               (condition-variable-broadcast! *cv*))
             (mutex-unlock! *mutex*)))
      (sys-sleep 1)
      (loop)))
  (do-monitor source))

;; Reads source file into *text-map*, updates global data.
;; *mutex* must be locked by the caller.   If an error occurs,
;; pull-text! unlocks *mutex*.
(define (pull-text! source trunc?)
  (when trunc? (tree-map-clear! *text-map*))
  (guard (e [else (mutex-unlock! *mutex*) (raise e)])
    (let ([pos (if trunc? 0 *size*)]
          [last-state (if trunc? '(#f . #f) *last-state*)])
      (receive (ttree new-state new-pos)
          (chaton-render-from-file source pos last-state)
        (tree-map-put! *text-map* pos (tree->string ttree))
        (set! *last-state* new-state)
        (set! *size* new-pos)))))

;;;
;;;   Comet threads
;;;

(define (spawn-child csock)
  (log-child csock "start")
  (thread-start! (make-thread (cut do-child csock))))

(define (do-child csock)
  (unwind-protect
      (guard (e [(eq? e 'eof) (log-child csock "disconnected")]
                [else (log-child csock "error ~s" (ref e'message))])
        (client-counter 'inc)
        (let1 pos (get-header csock)
          (if (>= pos 0)
            (emit-tail csock pos)
            (emit-skeleton (socket-output-port csock)))
          (log-child csock "finishing")))
    (begin
      (client-counter 'dec)
      (socket-close csock))))

;; returns the integer parameter given to the query
(define (get-header csock)
  (or (and-let* ([in (socket-input-port csock)]
                 [req (read-line in)]
                 [ (string? req) ]
                 [m (#/^GET\s+\/(?:\?t=\w+(?:&p=(\d+))?)?\s+HTTP\/1.1/i req)]
                 [hdrs (rfc822-header->list in)])
        (log-child csock "request ~s" req)
        (cond [(m 1) => x->integer] [else -1]))
      (raise 'eof))) 

;; NB: it may be more efficient if we send out existing content here,
;; instead of letting client to fetch it immediately after this reply.
;; A possible option for future development.
(define (emit-skeleton out)
  (write-tree (make-skeleton) out)
  (flush out))

(define (emit-tail csock pos)
  (let loop ()
    (mutex-lock! *mutex*)
    (cond [(equal? pos *size*)
           (if (mutex-unlock! *mutex* *cv* (+ 30 (random-integer 30)))
             (loop)
             (send-ping pos csock))]
          [(< pos *size*)
           (let ([s *size*] [t (text-retrieve *text-map* pos)])
             (mutex-unlock! *mutex*)
             (send-diff pos s t csock))]
          [else                         ;file is truncated?
           (let ([s *size*] [t (text-retrieve *text-map* 0)])
             (mutex-unlock! *mutex*)
             (send-diff 0 s t csock))])))

(define (send-diff start end text csock)
  (log-child csock "sending ~s-~s" start end)
  (send-json (format "{'pos':~s,'nc':~s,'ver':~s,'text':~s}"
                     end (client-counter 'get) "@@version@@"
                     text)
             csock))

(define (send-ping pos csock)
  (log-child csock "pinging back")
  (send-json (format "{'pos':~s,'nc':~s,'ver':~s,'text':''}"
                     pos (client-counter 'get) "@@version@@")
             csock))

(define (send-json json csock) 
  (let1 out (socket-output-port csock)
    (format out "HTTP/1.1 200 OK\r\n\
	         Content-type: application/json; charset=utf-8\r\n\
	         Content-length: ~s\r\n\r\n\
	         ~a" (string-size json) json)
    (flush out)))

(define (text-retrieve tmap start)
  (let loop ([key start]
             [r   '()])
    (if (not key)
      (string-concatenate-reverse r)
      (loop (tree-map-successor tmap key)
            (cons (tree-map-get tmap key "") r)))))

(define (log-child csock fmt . args)
  (log-format "(~a) ~a" (child-name csock) (apply format fmt args)))

(define (child-name csock)
  (and-let* ([addr (socket-address csock)])
    (sockaddr-name addr)))

;;;
;;;   Client counter
;;;

(define client-counter
  (let ([n 0] [mutex (make-mutex)])
    (lambda (msg)
      (case msg
        [(inc)  (with-locking-mutex mutex (lambda () (inc! n) n))]
        [(dec)  (with-locking-mutex mutex (lambda () (dec! n) n))]
        [(get)  n]
        [(reset)(with-locking-mutex mutex (lambda () (set! n 0)))]))))

;;;
;;;   Content to distribute
;;;

(define (make-skeleton)
  (html:html
   (html:head (html:title "Test")
              (html:link :href "@@httpd-url@@@@url-path@@chaton.css" :rel "Stylesheet" :type "text/css")
              (html:script :src "@@prototype-url@@" :type "text/javascript")
              (html:script :src "@@httpd-url@@@@url-path@@@@chaton-js@@"
                           :type "text/javascript"))
   (html:body
    :onload "fetchContent();"
    (html:div :id "view-pane")
    (html:div :id "status-pane" (html:p :id "status-line" "Connecting..."))
    )))

;;;
;;;  Daemon management
;;;

(define *pidfile* "@@server-data-dir@@viewer.pid")

(define (read-pid)
  (guard (e [(<system-error> e) #f])
    (string->number (sys-readlink *pidfile*))))

(define (write-pid)
  (sys-symlink (x->string (sys-getpid)) *pidfile*))

;;;
;;;  Initialize and shutdown
;;;

(define (initialize port)
  (guard (e [(<system-error> e)
             (cond [(read-pid)
                    => (lambda (pid)
                         (unless (= pid (sys-getpid))
                           (exit 1 "@@comet-script@@ seems already running \
                                   (pid ~a)." pid)))]
                   [else (exit 1 "@@comet-script@@ can't write pidfile (~a): \
                                  ~a" *pidfile* (ref e'message))])])
    (write-pid))
  (log-format "starting at port ~a" port)
  (set-signal-handler!
   (sys-sigset SIGINT SIGTERM)
   (lambda (s)
     (log-format "exitting by signal ~a" (sys-signal-name s))
     (cleanup))))

(define (cleanup)
  (sys-unlink *pidfile*)
  (exit 0))

(define (shutdown-viewer-server quiet?)
  (let1 pid (read-pid)
    (if pid
      (guard (e [(<system-error> e)
                 (exit 1 "Killing @@comet-script@@ failed: ~a" (ref e'message))])
        (sys-kill pid SIGINT)
        (unless quiet? (print "@@comet-script@@ pid "pid" is killed.")))
      (unless quiet? (print "@@comet-script@@ isn't running.")))))

(define (restart-viewer-server quiet?)
  (exit 1 "-r option not supported yet"))

;;;===================================================================

(select-module user)
(use gauche.logger)
(use gauche.parseopt)
(import chaton.viewer)

(define *port* @@comet-port@@)
(define *file* "@@server-data-dir@@data/current.dat")
(define *logfile* "@@server-data-dir@@logs/comet.log")

(define (main args)
  (let-args (cdr args) ([port "p|port=i" *port*]
                        [file "f|file=s" *file*]
                        [log  "l|log=s" *logfile*]
                        [kill "k|kill"]
                        [restart "r|restart"]
                        [quiet? "q|quiet"]
                        [else => (lambda _ (usage))])
    (cond
     [kill (shutdown-viewer-server quiet?)]
     [restart (restart-viewer-server quiet?)]
     [else (log-open (if (equal? log "-") #t log))
           (run-viewer-server port file)]))
  0)

(define (usage)
  (exit 1 #`"Usage: \
   \n  @@comet-script@@ [-p port][-f file][-l log] \
   \n  @@comet-script@@ -k|--kill\
   \n  @@comet-script@@ -r|--restart\
   \nOptions:\
   \n  The first form starts the Chaton viewer server.  The following\
   \n  options are accepted, though you shouldn't need to change the\
   \n  default values (showin in []) unless you're doing some experiment.\
   \n   -p, --port PORT   Specify the server port number.  [,*port*]\
   \n   -f, --file FILE   Specify the file the viewer monitors.\
   \n           [,*file*]\
   \n   -l, --log LOGFILE Specify the log file.  '-' for stdout.\
   \n           [,*logfile*]\
   \n  The second form (-k or --kill) shuts down the existing viewer.\
   \n  The third form (-r or --restart) restarts the running viewer if there's\
   \n  one, or starts a new viewer, in the background process."))

;; Local variables:
;; mode: scheme
;; end:
