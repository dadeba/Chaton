#!/usr/bin/env gosh

(add-load-path "@@server-data-dir@@")

(define-module chaton.viewer
  (use srfi-1)
  (use srfi-13)
  (use srfi-27)
  (use chaton)
  (use gauche.threads)
  (use gauche.net)
  (use gauche.logger)
  (use gauche.fcntl)
  (use gauche.process)
  (use text.html-lite)
  (use text.tree)
  (use rfc.822)
  (use file.util)
  (use util.match)
  (use util.list)
  (use www.cgi)
  (export +viewer-port+ +viewer-file+ +viewer-log+
          run-viewer-server restart-viewer-server shutdown-viewer-server
          check-viewer-server)
  )
(select-module chaton.viewer)

(define-constant +viewer-port+ (x->integer "@@comet-port@@"))
(define-constant +viewer-file+ "@@server-data-dir@@data/current.dat")
(define-constant +viewer-log+ "@@server-data-dir@@logs/comet.log")
(define-constant +credential+ "@@server-data-dir@@auth")

;; Global data shared between threads.  Accessor should lock *mutex* (ugh!).
(define *mutex* (make-mutex))
(define *cv* (make-condition-variable))
(define *size* 0)
(define *last-state* #f)
(define *text-map* (make-tree-map = <)) ; position -> rendered text fragment
(define *sexp-map* (make-tree-map = <)) ; position -> list of entries

;;;
;;;   Main entry
;;;

(define (run-viewer-server port source)
  (initialize port source)
  (let1 server-sock (make-server-socket 'inet port :reuse-addr? #t)
    (spawn-monitor source)
    (spawn-status)
    (spawn-client-tracker)
    (guard (e [else (log-format "main loop error: ~a" (ref e'message))
                    (cleanup)])
      (while #t (spawn-child (socket-accept server-sock))))))

;;;
;;;   Monitor thread
;;;

(define (spawn-monitor source)
  (log-format "monitor start on ~s" source)
  (mutex-lock! *mutex*)
  (pull-text! source #t)                ; this unlocks mutex when error.
  (mutex-unlock! *mutex*)
  (thread-start! (make-thread (cut do-monitor source))))

(define (do-monitor source)
  (guard (e [else (log-format "monitor error: ~s" (ref e'message))])
    (while #t
      (and (file-exists? source)
           (let1 s (file-size source)
             (mutex-lock! *mutex*)
             (unless (or (not s) (not *size*) (= s *size*))
               (log-format "monitor: source extended to ~s" s)
               (pull-text! source (< s *size*))
               (condition-variable-broadcast! *cv*))
             (mutex-unlock! *mutex*)))
      (sys-sleep 1)))
  (do-monitor source))

;; Reads source file into *text-map*, updates global data.
;; *mutex* must be locked by the caller.   If an error occurs,
;; pull-text! unlocks *mutex*.
(define (pull-text! source trunc?)
  (when trunc? (tree-map-clear! *text-map*) (tree-map-clear! *sexp-map*))
  (guard (e [else (mutex-unlock! *mutex*) (raise e)])
    (let ([pos (if trunc? 0 *size*)]
          [last-state (if trunc? #f *last-state*)])
      (receive (entries new-pos) (chaton-read-entries source pos)
        (receive (ttree new-state) (chaton-render entries last-state)
          (tree-map-put! *sexp-map* pos entries)
          (tree-map-put! *text-map* pos (tree->string ttree))
          (set! *last-state* new-state)
          (set! *size* new-pos))))))

;;;
;;;   Status thread
;;;

(define (spawn-status) (thread-start! (make-thread do-status)))

(define (do-status)
  (guard (e [else (log-format "status error: ~s" (ref e'message))])
    (let loop ((mtimes #f))
      (let1 mtimes1
          (map file-mtime `(,+sequence-file+ ,+last-post-file+ ,+num-chatters-file+))
        (unless (equal? mtimes mtimes1) (write-statuses))
        (sys-sleep 10)
        (loop mtimes1))))
  (do-status))

(define (write-statuses)
  (let ([s (x->integer (file->string +sequence-file+ :if-does-not-exist #f))]
        [l (x->integer (file->string +last-post-file+ :if-does-not-exist #f))]
        [n (x->integer (file->string +num-chatters-file+ :if-does-not-exist #f))])
    (make-directory* (sys-dirname +status.js+)) ;ensure dir
    (write-status-js s l n)
    (write-status-scm s l n)))

(define (write-status-js s l n)
  (with-output-to-file +status.js+
    (lambda () 
      (format #t "{\"last-post\":~s,\"num-chatters\":~s,\"post-sequence\":~s}"
              l n s))
    :atomic #t))

(define (write-status-scm s l n)
  (with-output-to-file +status.scm+
    (lambda ()
      (for-each (lambda (x) (write x) (newline))
                `((last-post ,l) (num-chatters ,n) (post-sequence ,s))))
    :atomic #t))

;;;
;;;   Comet threads
;;;

(define (spawn-child csock) (thread-start! (make-thread (cut do-child csock))))

(define (do-child csock)
  (unwind-protect
      (guard (e [(eq? e 'eof) (log-child csock "disconnected")]
                [(eq? e 'dup) (log-child csock "duplicate request")]
                [else (log-child csock "error ~s" (ref e'message))])
        (match-let1 (pos cid sexp?) (get-header csock)
          (if pos
            (emit-tail csock pos cid sexp?)
            (emit-skeleton (socket-output-port csock)))))
    (socket-close csock)))

;; returns the integer parameter given to the query
(define (get-header csock)
  (or (and-let* ([in (socket-input-port csock)]
                 [req (read-line in)]
                 [ (string? req) ]
                 [m (#/^GET\s+\/(?:\?(\S+)?)?\s+HTTP\/1.1/i req)]
                 [p (cond [(m 1) => (cut cgi-parse-parameters :query-string <>)]
                          [else '()])]
                 [hdrs (rfc822-header->list in)])
        (log-child csock "request ~s" req)
        (list (cgi-get-parameter "p" p :convert string->number) ;pos
              (cgi-get-parameter "c" p :convert string->number) ;cid
              (cgi-get-parameter "s" p)))                       ;sexpr?
      (raise 'eof))) 

;; NB: it may be more efficient if we send out existing content here,
;; instead of letting client to fetch it immediately after this reply.
;; A possible option for future development.
(define (emit-skeleton out)
  (let1 s (tree->string (make-skeleton (new-client-cid)))
    (write-tree `("HTTP/1.1 200 OK\r\n\
                   Content-type: text/html; charset=utf-8\r\n\
                   Content-length: ",(string-size s)"\r\n\r\n"
                   ,s)
                out)
    (flush out)))

;; Let the client wait until one of the following condition is met:
;;
;;  - The database file has changed (pos != *size*).  We send the
;;    added data back to the client.
;;  - The client disconnected.
;;  - 'Soft' timeout reached.   'Soft' timeout is somewhere between
;;    15-30 seconds.  In this case we check if the number of clients
;;    has been changed; if not, we wait again.  If it has, we send
;;    back a ping packet to notify the change of the number of clients.
;;  - 'Hard' timeout reached.   'Hard' timeout is around 5 minutes.
;;    We send back ping packet to the client anyway.  This is necessary
;;    to detect if the client is gone.

(define (emit-tail csock pos cid sexp?)
  (define ccnt (get-num-clients))
  (define time-started (sys-time))
  (define ncid (client-connected csock cid)) ; possibly update cid
  (let loop ()
    (mutex-lock! *mutex*)
    (cond [(equal? pos *size*)
           ;; wait until *size* changes or timeout
           (cond
            [(not (eqv? ncid cid)) ; this is reconnection after server restart.
             (mutex-unlock! *mutex*)
             (send-ping csock ncid pos sexp?)]
            [(mutex-unlock! *mutex* *cv* (+ 15 (random-integer 15))) (loop)]
            [(< time-started (- (sys-time) (+ 240 (random-integer 120))))
             (mutex-unlock! *mutex*)
             (send-ping csock ncid pos sexp?)] ; hard timeout
            [(and-let* ([ccnt2 (get-num-clients)]
                        [ (not (= ccnt ccnt2)) ])
               (mutex-unlock! *mutex*)
               (send-ping csock ncid pos sexp?) #t)] ; soft timeout, ccnt change
            [else (loop)])]
          [(< pos *size*)
           (let ([s *size*] [content (content-retrieve pos sexp?)])
             (mutex-unlock! *mutex*)
             (send-diff csock ncid pos s content sexp?))]
          [else                         ;file is truncated?
           (let ([s *size*] [content (content-retrieve 0 sexp?)])
             (mutex-unlock! *mutex*)
             (send-diff csock ncid 0 s content sexp?))])))

(define (send-diff csock cid start end content sexp?)
  (log-child csock "sending ~s-~s" start end)
  (send-reply csock cid end content sexp?))

(define (send-ping csock cid pos sexp?)
  (log-child csock "ping back ~a" cid)
  (send-reply csock cid pos #f sexp?))

(define (send-reply csock cid pos content sexp?)
  (client-replied csock cid)
  (let ([packet (make-packet cid pos content sexp?)]
        [out (socket-output-port csock)])
    (format out "HTTP/1.1 200 OK\r\n\
	         Content-type: application/~a; charset=utf-8\r\n\
	         Content-length: ~s\r\n\r\n\
	         ~a"
            (if sexp? "x-sexpr" "json") (string-size packet) packet)
    (flush out)))

(define (make-packet cid pos content sexp?)
  (if sexp?
    (write-to-string
     `((pos . ,pos) (nc . ,(get-num-clients)) (ver . "@@version@@")
       (cid . ,cid) (text . ,(or content '()))))
    (format "{\"pos\":~s,\"nc\":~s,\"ver\":~s,\"cid\":~s,\"text\":~s}"
            pos (get-num-clients) "@@version@@" cid (or content ""))))

(define (content-retrieve start sexp?)
  (define tmap (if sexp? *sexp-map* *text-map*))
  (define unit (if sexp? '() ""))
  (define merge (if sexp? (.$ concatenate reverse) string-concatenate-reverse))
  (let loop ([key start]
             [r   '()])
    (if (not key)
      (merge r)
      (loop (tree-map-successor tmap key)
            (cons (tree-map-get tmap key unit) r)))))

(define (log-child csock fmt . args)
  (log-format "(~a) ~a"
              (if-let1 addr (socket-address csock) (sockaddr-name addr) #f)
              (apply format fmt args)))

;;;
;;;   Client tracking
;;;

;; Client is identified by CID.  When client first connects to the comet
;; server we allocate a new CID for it.
;; *client-table* maps CID into:
;;    ClientEntry <connected?> <timestamp>
;; <Connected?> is #t if client's request is held by the comet server, and
;; #f if we send back a reply and the client has not yet issued a new request.
;; By the nature of Comet, it should be #t for most of the time.
;; <Timestamp> is the last time we sent back a reply to the client.
;;
;; If the client is not connected and <timestamp> is older than CLNT_TIMEOUT
;; from now, we assume the client is gone.  An active client usually reconnects
;; immediatly after we send back the reply, so we can set CLNT_TIMEOUT
;; fairly short.

(define *clnt-mutex* (make-mutex))
(define *clnt-table* (make-hash-table 'eqv?)) ; cid -> (waiting . timestamp)
(define-constant CLNT_TIMEOUT 10)
(define-constant CID_MAX #x10000000)

(define (make-cid-entry waiting?) (cons waiting? (sys-time)))
(define (cid-waiting? entry)      (car entry))
(define (cid-mark-waiting! entry) (set-car! entry #t))
(define (cid-unmark-waiting! entry)
  (begin (set-car! entry #f) (set-cdr! entry (sys-time))))
(define (cid-timestamp entry)     (cdr entry))

(define (%allocate-cid init?)
  (let loop ([cid (random-integer CID_MAX)])
    (cond [(hash-table-get *clnt-table* cid #f) (loop (random-integer CID_MAX))]
          [else (hash-table-put! *clnt-table* cid (make-cid-entry (not init?)))
                cid])))

(define (new-client-cid)
  (with-locking-mutex *clnt-mutex* (cut %allocate-cid #t)))

;; returns cid, possibly new one if the provided one is obsolete.
(define (client-connected csock cid)
  (with-locking-mutex *clnt-mutex*
    (lambda ()
      (cond [(hash-table-get *clnt-table* cid #f)
             => (lambda (e)
                  (if (cid-waiting? e) ; this is a duplicate request.
                    (raise 'dup)
                    (begin (cid-mark-waiting! e) cid)))]
            [else
             (rlet1 ncid (%allocate-cid #f)
               (log-child csock "child has unknown cid: ~a, reallocating ~a"
                          cid ncid))]))))

(define (client-replied csock cid)
  (with-locking-mutex *clnt-mutex*
    (lambda ()
      (cond [(hash-table-get *clnt-table* cid #f) => cid-unmark-waiting!]
            [else (log-child csock "child has unknown cid: ~a" cid)]))))

(define (get-num-clients)
  (with-locking-mutex *clnt-mutex* (cut hash-table-num-entries *clnt-table*)))

(define (client-sweep!)
  (with-locking-mutex *clnt-mutex*
    (lambda ()
      (let1 lim (- (sys-time) CLNT_TIMEOUT)
        (hash-table-for-each
         *clnt-table*
         (lambda (k v)
           (when (and (not (cid-waiting? v)) (<= (cid-timestamp v) lim))
             (log-format "client ~a gone" k)
             (hash-table-delete! *clnt-table* k))))))))

(define (spawn-client-tracker)
  (thread-start! (make-thread client-tracker)))

(define (client-tracker)
  (let loop ((nc (get-num-clients)))
    (sys-sleep 1)
    (guard (e [else (log-format "tracker: ~a" (ref e'message))])
      (client-sweep!))
    (let1 nnc (get-num-clients)
      (unless (= nc nnc)
        (with-output-to-file +num-chatters-file+ (cut write nc) :atomic #t))
      (loop nnc))))

;;;
;;;   Content to distribute
;;;

(define (make-skeleton cid)
  (html:html
   (html:head (html:title "Test")
              (html:link :href "@@httpd-url@@@@url-path@@chaton.css" :rel "Stylesheet" :type "text/css")
              (html:script :src "@@prototype-url@@" :type "text/javascript")
              (html:script :src "@@httpd-url@@@@url-path@@@@chaton-js@@"
                           :type "text/javascript"))
   (html:body
    :onload (format "initViewFrame(~d);" cid)
    (html:div :id "view-pane")
    (html:div :id "status-pane" (html:p :id "status-line" "Connecting..."))
    )))

;;;
;;;  Daemon management
;;;

(define *pidfile* "@@server-data-dir@@viewer.pid")

(define (read-pid)
  (guard (e [(<system-error> e) #f]) (string->number (sys-readlink *pidfile*))))

(define (write-pid) (sys-symlink (x->string (sys-getpid)) *pidfile*))

;;;
;;;  Initialize, shutdown, and process management
;;;

(define (initialize port file)
  (random-source-randomize! default-random-source)
  (guard (e [(<system-error> e)
             (if-let1 pid (read-pid)
               (unless (= pid (sys-getpid))
                 (exit 1 "@@comet-script@@ seems already running (pid ~a)." pid))
               (exit 1 "@@comet-script@@ can't write pidfile (~a): ~a"
                     *pidfile* (ref e'message)))])
    (write-pid))
  (log-format "starting at port ~a" port)
  (set-signal-handler!
   (sys-sigset SIGHUP SIGINT SIGTERM)
   (lambda (s)
     (log-format "exitting by signal ~a" (sys-signal-name s))
     (cleanup))))

(define (cleanup) (sys-unlink *pidfile*) (exit 0))

(define (shutdown-viewer-server quiet?)
  (if-let1 pid (read-pid)
    (guard (e [(<system-error> e)
               (exit 1 "Killing @@comet-script@@ failed: ~a" (ref e'message))])
      (sys-kill pid SIGINT)
      (unless quiet? (print "@@comet-script@@ pid "pid" is killed.")))
    (unless quiet? (print "@@comet-script@@ isn't running."))))

(define (check-viewer-server port)
  (if-let1 pid (read-pid)
    (if (check-running pid port)
      (print "@@comet-script@@ (pid "pid") running.")
      (print "@@comet-script@@ (pid "pid") does not respond.\
              \nYou might want to remove "*pidfile*"."))
    (print "@@comet-script@@ is not running.")))

(define (restart-viewer-server quiet? port file)
  (if-let1 pid (read-pid)
    (guard (e [(<system-error> e) (sys-unlink *pidfile*)])
      (sys-kill pid SIGTERM)
      (sys-sleep 1)))
  ;; We start new instance.
  ;; NB: We should be more careful about daemonization; better to
  ;; redirect stdout and stderr to /dev/null for the child process.
  (let1 pid (sys-fork)
    (cond [(= pid 0) (run-viewer-server port file)]
          [(check-running pid port)
           (unless quiet? (print "@@comet-script@@ Restarted (pid "pid")."))]
          [else (exit 1 "@@comet-script@@ couldn't be started.\n")])))

(define (check-running pid port)
  (let loop ((n 0))
    (cond [(= n 3) #f]                  ;retry limit
          [else
           (sys-sleep 1)
           (or (guard (e [(<system-error> e) #f])
                 (call-with-client-socket
                     (make-client-socket 'inet "localhost" port)
                   (lambda (in out)
                     (display "GET / HTTP/1.1\r\nhost: localhost\r\n\r\n" out)
                     (flush out)
                     (port->string in)
                     #t)))
               (loop (+ n 1)))])))

;;;===================================================================

(select-module user)
(use gauche.logger)
(use gauche.parseopt)
(import chaton.viewer)

(define (main args)
  (let-args (cdr args) ([port "p|port=i" +viewer-port+]
                        [file "f|file=s" +viewer-file+]
                        [log  "l|log=s"  +viewer-log+]
                        [kill "k|kill"]
                        [check "c|check"]
                        [restart "r|restart"]
                        [quiet? "q|quiet"]
                        [else => (lambda _ (usage))])
    (log-open (if (equal? log "-") #t log))
    (cond
     [kill    (shutdown-viewer-server quiet?)]
     [check   (check-viewer-server port)]
     [restart (restart-viewer-server quiet? port file)]
     [else    (run-viewer-server port file)]))
  0)

(define (usage)
  (exit 1 #`"Usage:\
   \n  @@comet-script@@ [-p port][-f file][-l log]\
   \n  @@comet-script@@ -k|--kill\
   \n  @@comet-script@@ -c|--check [-p port]\
   \n  @@comet-script@@ -r|--restart [-p port][-f file][-l log]\
   \nOptions:\
   \n  The first form starts the Chaton viewer server.  The following\
   \n  options are accepted, though you shouldn't need to change the\
   \n  default values (showin in []) unless you're doing some experiment.\
   \n   -p, --port PORT   Specify the server port number.  [,+viewer-port+]\
   \n   -f, --file FILE   Specify the file the viewer monitors.\
   \n           [,+viewer-file+]\
   \n   -l, --log LOGFILE Specify the log file.  '-' for stdout.\
   \n           [,+viewer-log+]\
   \n  The second form (-k or --kill) shuts down the existing viewer.\
   \n  The third form (-c or --check) checks if the server is running.\
   \n  The fourth form (-r or --restart) restarts the running viewer if there's\
   \n  one, or starts a new viewer, in the background process.\n"))

;; Local variables:
;; mode: scheme
;; end:
