#!/usr/bin/env gosh
;; This script should be run periodically to truncate and
;; save the logs.

(add-load-path "@@server-data-dir@@")

(define-module chaton.archiver
  (use file.util)
  (use file.filter)
  (use util.match)
  (use gauche.fcntl)
  (use gauche.parameter)
  (use gauche.parseopt)
  (use gauche.sequence)
  (use srfi-19)
  (use chaton)
  (export run-archiver))
(select-module chaton.archiver)

(define-constant *datadir* "@@server-data-dir@@data")
(define-constant *current.dat* (build-path *datadir* "current.dat"))
(define-constant *current.dat.bak* (build-path *datadir* "current.dat.bak"))

;; The base time zone offset (the offset when DST is not in effect)
;; of the location we're running.
(define-constant *tzoff*
  (let1 now (current-date)
    (- (date-zone-offset now)
       (if (zero? (ref (sys-localtime (time-second (date->time-utc now)))'isdst))
         0 3600))))

(define verbose (make-parameter #f))
(define notrunc (make-parameter #f)) ; suppress truncating current.dat

(define (report fmt . args)
  (when (verbose) (apply format #t fmt args)))

;;;
;;;  Fetch the data file
;;;

;; Read in the current.dat.  Returns a list of canonicalized entry.
;;  <entry> : (<nickname> <timestamps> <text> <ipaddr>)
;;  <timestamps> : (<seconds> <microseconds> <date-in-seconds>)
;; Where <date-in-seconds> is seconds from UTC to the beginning of the
;; day in localtime when the entry is created.
;;
(define (read-current current.dat)
  (call-with-input-file current.dat
    (lambda (in)
      (if in
        (reverse (port-fold canonicalize-entry '() (cut read-line in)))
        '()))
    :if-does-not-exist #f))

(define (safe-read line)
  (guard (e [(<read-error> e) e]) (read-from-string line)))

(define (canonicalize-entry line entries)
  (match (safe-read line)
    [(nick (secs usecs) text . opt)
     `((,nick (,secs ,usecs ,(date-in-seconds secs)) ,text
              ,(if (pair? opt) (car opt) "0.0.0.0"))
       ,@entries)]
    [(? <read-error> x) (warn "unreadable entry: ~a" (ref x'message))]
    [other (warn "unrecognized entry: ~s" other)]))

;; extract DIS part of canonicalized entry
(define (entry-dis entry) (match entry [(_ (_ _ dis) _ _) dis]))

;; Retruns a list of dates (date-in-seconds) in entries.
(define (existing-diss entries)
  (let1 diss '()
    (dolist (e entries)
      (let1 dis (entry-dis e)
        (unless (memv dis diss) (push! diss dis))))
    (sort diss)))

;;;
;;;  Write entries
;;;

(define (write-entries entries file)
  (let1 tmp #`",|file|.tmp"
    (with-output-to-file tmp
      (lambda ()
        (dolist (e entries)
          (match-let1 (nick (s u _) text ipaddr) e
            (write `(,nick (,s ,u) ,text ,ipaddr)) (newline)))))
    (sys-rename tmp file)))

(define (write-daily-entry entries dis)
  (let ([es (filter-entry entries (cut = dis <>) #f)]
        [file (daily-log-path dis)])
    (cond [(null? es)]
          [(and (file-exists? file)
                (not (file-is-symlink? file)))
           (report "archive file ~a exists.  skipping.\n" file)]
          [else
           (report "generating ~a\n" file)
           (make-directory* (sys-dirname file))
           (write-entries es file)])))

(define (truncate-current entries dis)
  (let1 tmp #`",|*current.dat*|.tmp"
    (write-entries (filter-entry entries (cut <= dis <>) 30) tmp)
    (cond [(file-equal? tmp *current.dat*)
           (report "~a unchanged.\n" *current.dat*) (sys-unlink tmp)]
          [else
           (report "truncating ~a\n" *current.dat*)
           (sys-rename *current.dat* *current.dat.bak*)
           (sys-rename tmp *current.dat*)])))

(define (daily-log-path dis)
  (let1 tm (sys-localtime dis)
    (build-path *datadir* (format "~4,'0d/~2,'0d/~2,'0d.dat"
                                  (+ (ref tm'year) 1900)
                                  (+ (ref tm'mon) 1)
                                  (ref tm'mday)))))

(define (filter-entry entries check-date min-entries)
  (let* ([num-entries (length entries)]
         [erase-limit (if (and min-entries (>= num-entries min-entries))
                        (- num-entries min-entries)
                        +inf.0)])
    (reverse (values-ref
              (fold2 (lambda (e r cnt)
                       (values (if (or (>= cnt erase-limit)
                                       (check-date (entry-dis e)))
                                 (cons e r)
                                 r)
                               (+ cnt 1)))
                     '() 1 entries)
              0))))

;;;
;;;  Chore for the day
;;;

(define (chore-for-the-day today-dis)
  (chaton-with-exclusive-locking
   (lambda ()
     (let* ([entries (read-current *current.dat*)]
            [diss    (existing-diss entries)])
       (dolist [dis diss]
         (when (< dis today-dis)
           (write-daily-entry entries dis)))
       (truncate-current entries today-dis)
       (mklink (daily-log-path today-dis))
       (mklink (daily-log-path (dis+ today-dis 1)))))))

(define (mklink daily-file)
  (cond [(file-exists? daily-file)
         (report "link ~a exists.  skipping.\n" daily-file)]
        [else
         (report "creating link ~a\n" daily-file)
         (sys-symlink "../../current.dat" daily-file)]))

(define (run-archiver args)
  (let-args (cdr args) ([q "q|quiet"]
                        [n "n|notrunc"]
                        [else => (lambda (_) (usage (car args)))]
                        . args)
    (parameterize ([verbose (not q)]
                   [notrunc n])
      (match args
        [()        (chore-for-the-day (current-dis))]
        [(datestr) (chore-for-the-day (parse-date datestr))]))
    0))

(define (usage argv0)
  (exit 1 #`"Usage: ,argv0 [-q|quiet] [date] \
   \nOptions:\
   \n -q, --quiet    Operate quietly."))

;;;
;;; Date utilities
;;;

;; Returns unix time of the beginning of the day.
(define (parse-date str)
  (rxmatch-case str
    [#/^(\d\d\d\d)\/(\d{1,2})\/(\d{1,2})$/ (_ y m d)
     (let ([yy (x->integer y)]
           [mm (x->integer m)]
           [dd (x->integer d)])
       (unless (and (<= 2000 yy)
                    (<= 1 mm 12)
                    (<= 1 dd 31))
         (exit 1 "bad date: ~a" str))
       (make-dis yy mm dd))]
    [else (exit 1 "bad date: ~a" str)]))

;; Returns unix time of the beginning of the day when SECONDS is.
;; TZOFF should be a timezone offset _without_DST_ in the location where
;; this program is running.
;; Rely on sys-localtime to handle timezone properly (srfi-19 always
;; use the timezone of the current time, which leads incorrect behavior
;; if we archiving across the boundary of DST change).
(define (date-in-seconds seconds)
  (let1 tm (sys-localtime seconds)
    (time-second
     (date->time-utc
      (make-date 0 0 0 0 (ref tm 'mday) (+ (ref tm 'mon) 1)
                 (+ (ref tm 'year) 1900)
                 (if (= (ref tm 'isdst) 0) *tzoff* (+ *tzoff* 3600)))))))

;; Returns unix time of the beginning of the day Y/M/D.
;; If we use midnight, it can be off one-day if the date
;; is on the DST boundary; so we use noon and then truncate it
;; by date-in-seconds.
(define (make-dis y m d)
  (date-in-seconds
   (time-second
    (date->time-utc (make-date 0 0 0 12 d m y *tzoff*)))))

(define (current-dis) (date-in-seconds (sys-time)))

;; Add DAYS to the date represented in DIS.
;; We assume DAYS is a few days, so we only cross the DST boundary
;; at most once.
(define (dis+ dis days)
  (let ([isdst0 (ref (sys-localtime dis)'isdst)]
        [isdst1 (ref (sys-localtime (+ dis (* days 86400)))'isdst)])
    (cond
     [(= isdst0 isdst1) (+ dis 86400)]
     [(< isdst0 isdst1) (+ dis (- 86400 3600))] ;entering DST
     [else              (+ dis (+ 86400 3600))] ;leaving DST
     )))

;;;===================================================================

(select-module user)
(import chaton.archiver)
(define main run-archiver)

;; Local variables:
;; mode: scheme
;; end:
